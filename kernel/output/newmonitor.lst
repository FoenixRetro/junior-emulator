
; 64tass Turbo Assembler Macro V1.58.2974? listing file
; 64tass "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$34000" "-D SOURCE_ADDRESS=\$28000" "-D SPRITE_ADDRESS=\$30000" "-D LTILEMAP_ADDRESS=\$24000" "-D LTILEIMAGES_ADDRESS=\$26000" -q -c -b -o monitor.rom -L output/newmonitor.lst newmonitor.asm
; Fri Feb 17 16:22:51 2023

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=$e000					 MONITOR_ADDRESS=$E000
=$f000					 LOCKOUT_ADDRESS=$F000
=$34000					 BASIC_ADDRESS=$34000
=$28000					 SOURCE_ADDRESS=$28000
=$30000					 SPRITE_ADDRESS=$30000
=$24000					 LTILEMAP_ADDRESS=$24000
=$26000					 LTILEIMAGES_ADDRESS=$26000

;******  Processing input file: newmonitor.asm

=$fc					zTemp0 = $FC 								; 2 byte memory units.
=$f0					eventBuffer = $F0 							; location of event buffer.
=6					ClockMhz = 6 								; clock speed in MHz (affects repeat timing)
=1					KeyboardInvert = 1 							; 0 if keyboard active high, 1 if active low.
=8					KQSize = 8 									; size of keyboard queue
=$200					StartWorkSpace = $200
=$203					XPosition = $203 							; X Character position
=$204					YPosition = $204 							; Y Character position
=$205					TextColour = $205 							; Text colour
=$206					CurrentPage = $206 							; current I/O page
=$207					KeysInQueue = $207 							; last key press
=$208					ReleaseFlag = $208 							; set to non-zero if release code (F0) received
=$209					ScanShiftFlag = $209 						; set to zero for shift, $80 for shifted scans ($E0)
=$210					KeyStatus = $210 							; status bits for keys, 32 x 8 bits = 256 bits.
=560					KeyboardQueue = $210+32
=568					EndWorkSpace = KeyboardQueue+KQSize
=80					CWidth = 80 								; display size
=60					CHeight = 60
=1					IOPageRegister = 1 							; select I/O Page

;******  Processing file: include/vicky.inc

=$d000					MASTER_CTRL_REG_L	    = $D000
=$01					Mstr_Ctrl_Text_Mode_En  = $01       ; Enable the Text Mode
=$02					Mstr_Ctrl_Text_Overlay  = $02       ; Enable the Overlay of the text mode on top of Graphic Mode (the Background Color is ignored)
=$04					Mstr_Ctrl_Graph_Mode_En = $04       ; Enable the Graphic Mode
=$08					Mstr_Ctrl_Bitmap_En     = $08       ; Enable the Bitmap Module In Vicky
=$10					Mstr_Ctrl_TileMap_En    = $10       ; Enable the Tile Module in Vicky
=$20					Mstr_Ctrl_Sprite_En     = $20       ; Enable the Sprite Module in Vicky
=$40					Mstr_Ctrl_GAMMA_En      = $40       ; this Enable the GAMMA correction - The Analog and DVI have different color value, the GAMMA is great to correct the difference
=$80					Mstr_Ctrl_Disable_Vid   = $80       ; This will disable the Scanning of the Video hence giving 100% bandwith to the CPU
=$d001					MASTER_CTRL_REG_H	    = $D001
=$d002					VKY_RESERVED_00         = $D002
=$d003					VKY_RESERVED_01         = $D003
=$d004					BORDER_CTRL_REG         = $D004 ; Bit[0] - Enable (1 by default)  Bit[4..6]: X Scroll Offset ( Will scroll Left) (Acceptable Value: 0..7)
=$01					Border_Ctrl_Enable      = $01
=$d005					BORDER_COLOR_B          = $D005
=$d006					BORDER_COLOR_G          = $D006
=$d007					BORDER_COLOR_R          = $D007
=$d008					BORDER_X_SIZE           = $D008; X-  Values: 0 - 32 (Default: 32)
=$d009					BORDER_Y_SIZE           = $D009; Y- Values 0 -32 (Default: 32)
=$d00a					VKY_RESERVED_02         = $D00A
=$d00b					VKY_RESERVED_03         = $D00B
=$d00c					VKY_RESERVED_04         = $D00C
=$d00d					BACKGROUND_COLOR_B      = $D00D ; When in Graphic Mode, if a pixel is "0" then the Background pixel is chosen
=$d00e					BACKGROUND_COLOR_G      = $D00E
=$d00f					BACKGROUND_COLOR_R      = $D00F ;
=$d010					VKY_TXT_CURSOR_CTRL_REG = $D010   ;[0]  Enable Text Mode
=$01					Vky_Cursor_Enable       = $01
=$02					Vky_Cursor_Flash_Rate0  = $02
=$04					Vky_Cursor_Flash_Rate1  = $04
=$d011					VKY_TXT_START_ADD_PTR   = $D011   ; This is an offset to change the Starting address of the Text Mode Buffer (in x)
=$d012					VKY_TXT_CURSOR_CHAR_REG = $D012
=$d013					VKY_TXT_CURSOR_COLR_REG = $D013
=$d014					VKY_TXT_CURSOR_X_REG_L  = $D014
=$d015					VKY_TXT_CURSOR_X_REG_H  = $D015
=$d016					VKY_TXT_CURSOR_Y_REG_L  = $D016
=$d017					VKY_TXT_CURSOR_Y_REG_H  = $D017
=$d018					VKY_LINE_IRQ_CTRL_REG   = $D018 ;[0] - Enable Line 0 - WRITE ONLY
=$d019					VKY_LINE_CMP_VALUE_LO  = $D019 ;Write Only [7:0]
=$d01a					VKY_LINE_CMP_VALUE_HI  = $D01A ;Write Only [3:0]
=$d018					VKY_PIXEL_X_POS_LO     = $D018 ; This is Where on the video line is the Pixel
=$d019					VKY_PIXEL_X_POS_HI     = $D019 ; Or what pixel is being displayed when the register is read
=$d01a					VKY_LINE_Y_POS_LO      = $D01A ; This is the Line Value of the Raster
=$d01b					VKY_LINE_Y_POS_HI      = $D01B ;
=$d100					TyVKY_BM0_CTRL_REG       = $D100
=$01					BM0_Ctrl                = $01       ; Enable the BM0
=$02					BM0_LUT0                = $02       ; LUT0
=$04					BM0_LUT1                = $04       ; LUT1
=$08					BM0_LUT2                = $08       ; LUT2
=$d101					TyVKY_BM0_START_ADDY_L   = $D101
=$d102					TyVKY_BM0_START_ADDY_M   = $D102
=$d103					TyVKY_BM0_START_ADDY_H   = $D103
=$d108					TyVKY_BM1_CTRL_REG       = $D108
=$01					BM1_Ctrl                = $01       ; Enable the BM0
=$02					BM1_LUT0                = $02       ; LUT0
=$04					BM1_LUT1                = $04       ; LUT1
=$08					BM1_LUT2                = $08       ; LUT2
=$d109					TyVKY_BM1_START_ADDY_L   = $D109
=$d10a					TyVKY_BM1_START_ADDY_M   = $D10A
=$d10b					TyVKY_BM1_START_ADDY_H   = $D10B
=$d200					TyVKY_TL_CTRL0          = $D200
=$d300					TyVKY_TL_MISC           = $D300
=$d800					TEXT_LUT_FG      = $D800
=$d840					TEXT_LUT_BG		 = $D840
=$d000					TyVKY_LUT0              = $D000 ; -$D000 - $D3FF
=$d400					TyVKY_LUT1              = $D400 ; -$D400 - $D7FF
=$d800					TyVKY_LUT2              = $D800 ; -$D800 - $DBFF
=$dc00					TyVKY_LUT3              = $DC00 ; -$DC00 - $DFFF

;******  Return to file: newmonitor.asm


;******  Processing file: include/interrupt.inc

=$d660					INT_PENDING_REG0 = $D660 ;
=$d661					INT_PENDING_REG1 = $D661 ;
=$d662					INT_PENDING_REG2 = $D662 ; NOT USED
=$d663					INT_PENDING_REG3 = $D663 ; NOT USED
=$d664					INT_POL_REG0     = $D664 ;
=$d665					INT_POL_REG1     = $D665 ;
=$d666					INT_POL_REG2     = $D666 ;  NOT USED
=$d667					INT_POL_REG3     = $D667 ; NOT USED
=$d668					INT_EDGE_REG0    = $D668 ;
=$d669					INT_EDGE_REG1    = $D669 ;
=$d66a					INT_EDGE_REG2    = $D66A ; NOT USED
=$d66b					INT_EDGE_REG3    = $D66B ; NOT USED
=$d66c					INT_MASK_REG0    = $D66C ;
=$d66d					INT_MASK_REG1    = $D66D ;
=$d66e					INT_MASK_REG2    = $D66E ; NOT USED
=$d66f					INT_MASK_REG3    = $D66F ; NOT USED
=$01					JR0_INT00_SOF        = $01  ;Start of Frame @ 60FPS
=$02					JR0_INT01_SOL        = $02  ;Start of Line (Programmable)
=$04					JR0_INT02_KBD        = $04  ;
=$08					JR0_INT03_MOUSE      = $08  ;
=$10					JR0_INT04_TMR0       = $10  ;
=$20					JR0_INT05_TMR1       = $20  ;Real-Time Clock Interrupt
=$40					JR0_INT06_DMA        = $40  ;Floppy Disk Controller
=$80					JR0_INT07_TBD        = $80  ; Mouse Interrupt (INT12 in SuperIO IOspace)
=$01					JR1_INT00_UART       = $01  ;Keyboard Interrupt
=$02					JR1_INT01_COL0       = $02  ;TYVKY Collision TBD
=$04					JR1_INT02_COL1       = $04  ;TYVKY Collision TBD
=$08					JR1_INT03_COL2       = $08  ;TYVKY Collision TBD
=$10					JR1_INT04_RTC        = $10  ;Serial Port 1
=$20					JR1_INT05_VIA        = $20  ;Midi Controller Interrupt
=$40					JR1_INT06_IEC        = $40  ;Parallel Port
=$80					JR1_INT07_SDCARD     = $80  ;SDCard Insert

;******  Return to file: newmonitor.asm


;******  Processing file: src/hardware.asm

.e000					TinyVickyInitialise:
.e000	a9 01		lda #$01	            lda # Mstr_Ctrl_Text_Mode_En        ; Text on, Overlay,Graphic,Bitmap,Tilemap,Sprite,Gamma,Disable off.
.e002	8d 00 d0	sta $d000	            sta MASTER_CTRL_REG_L               ; Register $D000 in page 0
.e005	ad 00 d0	lda $d000	            lda MASTER_CTRL_REG_L
.e008	a9 01		lda #$01	            lda #Border_Ctrl_Enable             ; Enable border
.e00a	8d 04 d0	sta $d004	            sta BORDER_CTRL_REG                 ; Register $D004 in page 0
.e00d	a9 80		lda #$80	            lda #$80                            ; set border colour to $804000
.e00f	8d 05 d0	sta $d005	            sta BORDER_COLOR_B                  ; (registers $D005..$D007)
.e012	a9 00		lda #$00	            lda #$00
.e014	8d 06 d0	sta $d006	            sta BORDER_COLOR_G
.e017	a9 00		lda #$00	            lda #$00
.e019	8d 07 d0	sta $d007	            sta BORDER_COLOR_R
.e01c	a9 10		lda #$10	            lda #16                             ; border size (offset from top left ?)
.e01e	8d 08 d0	sta $d008	            sta BORDER_X_SIZE                   ; (registers $D008 .. $D009)
.e021	8d 09 d0	sta $d009	            sta BORDER_Y_SIZE
.e024	a9 05		lda #$05	            lda #Vky_Cursor_Enable | Vky_Cursor_Flash_Rate1
.e026	8d 10 d0	sta $d010	            sta VKY_TXT_CURSOR_CTRL_REG         ; turn cursor on ($D010)
.e029	a9 06		lda #$06	            lda #6
.e02b	8d 12 d0	sta $d012	            sta VKY_TXT_CURSOR_CHAR_REG         ; 160 is 128+32 so inverse space. ($D012)
.e02e	a9 1c		lda #$1c	            lda #28
.e030	8d 13 d0	sta $d013	            sta VKY_TXT_CURSOR_COLR_REG         ; colour $2 $8 ($D013)
.e033	a9 00		lda #$00	            lda #0                              ; cursor to (0,5)
.e035	8d 14 d0	sta $d014	            sta VKY_TXT_CURSOR_X_REG_L          ; ($D014 .. $D017)
.e038	8d 15 d0	sta $d015	            sta VKY_TXT_CURSOR_X_REG_H
.e03b	8d 17 d0	sta $d017	            sta VKY_TXT_CURSOR_Y_REG_H
.e03e	a9 05		lda #$05	            lda #5
.e040	8d 16 d0	sta $d016	            sta VKY_TXT_CURSOR_Y_REG_L
.e043	a9 16		lda #$16	            lda		#$16   						; set text colour.
.e045	8d 05 02	sta $0205	            sta 	TextColour
.e048	60		rts		            rts
.e049					Init_Text_LUT
.e049	a2 00		ldx #$00	                LDX #$00
.e04b	bd 64 e0	lda $e064,x	lutinitloop0    LDA fg_color_lut,x      ; get Local Data
.e04e	9d 00 d8	sta $d800,x	                sta TEXT_LUT_FG,x   ; Write in LUT Memory ($D800)
.e051	e8		inx		                inx
.e052	e0 40		cpx #$40	                cpx #$40
.e054	d0 f5		bne $e04b	                bne lutinitloop0
.e056	a2 00		ldx #$00	                LDX #$00
.e058	bd a4 e0	lda $e0a4,x	lutinitloop1    LDA bg_color_lut,x      ; get Local Data
.e05b	9d 40 d8	sta $d840,x	                STA TEXT_LUT_BG,x   ; Write in LUT Memory ($D840)
.e05e	e8		inx		                INX
.e05f	e0 40		cpx #$40	                CPX #$40
.e061	d0 f5		bne $e058	                bne lutinitloop1
.e063	60		rts		                RTS
>e064	00 00 00 ff			fg_color_lut    .text $00, $00, $00, $FF
>e068	00 00 80 ff			                .text $00, $00, $80, $FF        ; blue
>e06c	00 80 00 ff			                .text $00, $80, $00, $FF        ; green
>e070	80 00 00 ff			                .text $80, $00, $00, $FF        ; red
>e074	00 80 80 ff			                .text $00, $80, $80, $FF        ; yellow (etc.)
>e078	80 80 00 ff			                .text $80, $80, $00, $FF
>e07c	80 00 80 ff			                .text $80, $00, $80, $FF
>e080	80 80 80 ff			                .text $80, $80, $80, $FF
>e084	00 45 ff ff			                .text $00, $45, $FF, $FF
>e088	13 45 8b ff			                .text $13, $45, $8B, $FF
>e08c	00 00 20 ff			                .text $00, $00, $20, $FF
>e090	00 20 00 ff			                .text $00, $20, $00, $FF
>e094	20 00 00 ff			                .text $20, $00, $00, $FF
>e098	20 20 20 ff			                .text $20, $20, $20, $FF
>e09c	ff 80 00 ff			                .text $FF, $80, $00, $FF
>e0a0	ff ff ff ff			                .text $FF, $FF, $FF, $FF
>e0a4	00 00 00 ff			bg_color_lut    .text $00, $00, $00, $FF  ;BGRA
>e0a8	aa 00 00 ff			                .text $AA, $00, $00, $FF
>e0ac	00 80 00 ff			                .text $00, $80, $00, $FF
>e0b0	00 00 80 ff			                .text $00, $00, $80, $FF
>e0b4	00 20 20 ff			                .text $00, $20, $20, $FF
>e0b8	20 20 00 ff			                .text $20, $20, $00, $FF
>e0bc	20 00 20 ff			                .text $20, $00, $20, $FF
>e0c0	20 20 20 ff			                .text $20, $20, $20, $FF
>e0c4	1e 69 d2 ff			                .text $1E, $69, $D2, $FF
>e0c8	13 45 8b ff			                .text $13, $45, $8B, $FF
>e0cc	00 00 20 ff			                .text $00, $00, $20, $FF
>e0d0	00 20 00 ff			                .text $00, $20, $00, $FF
>e0d4	40 00 00 ff			                .text $40, $00, $00, $FF
>e0d8	10 10 10 ff			                .text $10, $10, $10, $FF
>e0dc	40 40 40 ff			                .text $40, $40, $40, $FF
>e0e0	ff ff ff ff			                .text $FF, $FF, $FF, $FF
.e0e4					IRQHandler
.e0e4	48		pha		                pha
.e0e5	a5 01		lda $01		                lda     1
.e0e7	48		pha		                pha
.e0e8	29 f8		and #$f8	                and     #$F8
.e0ea	85 01		sta $01		                sta     1
.e0ec	ad 60 d6	lda $d660	                LDA INT_PENDING_REG0                ; received Keyboard interrupt ?
.e0ef	29 04		and #$04	                AND #JR0_INT02_KBD
.e0f1	c9 04		cmp #$04	                CMP #JR0_INT02_KBD
.e0f3	d0 0d		bne $e102	                BNE EXIT_IRQ_HANDLE
.e0f5	ad 44 d6	lda $d644	                lda     $D644                       ; shouldn't be empty
.e0f8	29 01		and #$01	                and     #1
.e0fa	d0 06		bne $e102	                bne     EXIT_IRQ_HANDLE
.e0fc	ad 42 d6	lda $d642	                lda     $D642
.e0ff	20 44 e8	jsr $e844	                jsr     HandleKeyboard
.e102					EXIT_IRQ_HANDLE:
.e102	ad 60 d6	lda $d660	                lda INT_PENDING_REG0
.e105	8d 60 d6	sta $d660	                sta INT_PENDING_REG0
.e108	ad 61 d6	lda $d661	                lda INT_PENDING_REG1
.e10b	8d 61 d6	sta $d661	                sta INT_PENDING_REG1
.e10e	68		pla		                pla
.e10f	85 01		sta $01		                sta     1
.e111	68		pla		                pla
.e112	40		rti		                rti
.e113					LoadGraphicsLUT:
.e113	20 ae e6	jsr $e6ae	            jsr     SelectPage1
.e116	a2 00		ldx #$00	            ldx     #0
.e118	bd 34 e1	lda $e134,x	_LGLLoop:   lda     _GraphicsLUT,x
.e11b	9d 00 d0	sta $d000,x	            sta     TyVKY_LUT0,x
.e11e	bd 34 e2	lda $e234,x	            lda     _GraphicsLUT+256,x
.e121	9d 00 d1	sta $d100,x	            sta     TyVKY_LUT0+256,x
.e124	bd 34 e3	lda $e334,x	            lda     _GraphicsLUT+512,x
.e127	9d 00 d2	sta $d200,x	            sta     TyVKY_LUT0+512,x
.e12a	bd 34 e4	lda $e434,x	            lda     _GraphicsLUT+768,x
.e12d	9d 00 d3	sta $d300,x	            sta     TyVKY_LUT0+768,x
.e130	ca		dex		            dex
.e131	d0 e5		bne $e118	            bne     _LGLLoop
.e133	60		rts		            rts
.e134					_GraphicsLUT:
>e134	00 00 00 00 aa 00 00 00		            .binary    "gfxlut.palette"
>e13c	00 aa 00 00 aa aa 00 00 00 00 aa 00 aa 00 aa 00
>e14c	00 55 aa 00 aa aa aa 00 55 55 55 00 ff 55 55 00
>e15c	55 ff 55 00 ff ff 55 00 55 55 ff 00 ff 55 ff 00
>e16c	55 ff ff 00 ff ff ff 00 00 00 00 00 10 10 10 00
>e17c	20 20 20 00 35 35 35 00 45 45 45 00 55 55 55 00
>e18c	65 65 65 00 75 75 75 00 8a 8a 8a 00 9a 9a 9a 00
>e19c	aa aa aa 00 ba ba ba 00 ca ca ca 00 df df df 00
>e1ac	ef ef ef 00 ff ff ff 00 ff 00 00 00 ff 00 41 00
>e1bc	ff 00 82 00 ff 00 be 00 ff 00 ff 00 be 00 ff 00
>e1cc	82 00 ff 00 41 00 ff 00 00 00 ff 00 00 41 ff 00
>e1dc	00 82 ff 00 00 be ff 00 00 ff ff 00 00 ff be 00
>e1ec	00 ff 82 00 00 ff 41 00 00 ff 00 00 41 ff 00 00
>e1fc	82 ff 00 00 be ff 00 00 ff ff 00 00 ff be 00 00
>e20c	ff 82 00 00 ff 41 00 00 ff 82 82 00 ff 82 9e 00
>e21c	ff 82 be 00 ff 82 df 00 ff 82 ff 00 df 82 ff 00
>e22c	be 82 ff 00 9e 82 ff 00 82 82 ff 00 82 9e ff 00
>e23c	82 be ff 00 82 df ff 00 82 ff ff 00 82 ff df 00
>e24c	82 ff be 00 82 ff 9e 00 82 ff 82 00 9e ff 82 00
>e25c	be ff 82 00 df ff 82 00 ff ff 82 00 ff df 82 00
>e26c	ff be 82 00 ff 9e 82 00 ff ba ba 00 ff ba ca 00
>e27c	ff ba df 00 ff ba ef 00 ff ba ff 00 ef ba ff 00
>e28c	df ba ff 00 ca ba ff 00 ba ba ff 00 ba ca ff 00
>e29c	ba df ff 00 ba ef ff 00 ba ff ff 00 ba ff ef 00
>e2ac	ba ff df 00 ba ff ca 00 ba ff ba 00 ca ff ba 00
>e2bc	df ff ba 00 ef ff ba 00 ff ff ba 00 ff ef ba 00
>e2cc	ff df ba 00 ff ca ba 00 71 00 00 00 71 00 1c 00
>e2dc	71 00 39 00 71 00 55 00 71 00 71 00 55 00 71 00
>e2ec	39 00 71 00 1c 00 71 00 00 00 71 00 00 1c 71 00
>e2fc	00 39 71 00 00 55 71 00 00 71 71 00 00 71 55 00
>e30c	00 71 39 00 00 71 1c 00 00 71 00 00 1c 71 00 00
>e31c	39 71 00 00 55 71 00 00 71 71 00 00 71 55 00 00
>e32c	71 39 00 00 71 1c 00 00 71 39 39 00 71 39 45 00
>e33c	71 39 55 00 71 39 61 00 71 39 71 00 61 39 71 00
>e34c	55 39 71 00 45 39 71 00 39 39 71 00 39 45 71 00
>e35c	39 55 71 00 39 61 71 00 39 71 71 00 39 71 61 00
>e36c	39 71 55 00 39 71 45 00 39 71 39 00 45 71 39 00
>e37c	55 71 39 00 61 71 39 00 71 71 39 00 71 61 39 00
>e38c	71 55 39 00 71 45 39 00 71 51 51 00 71 51 59 00
>e39c	71 51 61 00 71 51 69 00 71 51 71 00 69 51 71 00
>e3ac	61 51 71 00 59 51 71 00 51 51 71 00 51 59 71 00
>e3bc	51 61 71 00 51 69 71 00 51 71 71 00 51 71 69 00
>e3cc	51 71 61 00 51 71 59 00 51 71 51 00 59 71 51 00
>e3dc	61 71 51 00 69 71 51 00 71 71 51 00 71 69 51 00
>e3ec	71 61 51 00 71 59 51 00 41 00 00 00 41 00 10 00
>e3fc	41 00 20 00 41 00 31 00 41 00 41 00 31 00 41 00
>e40c	20 00 41 00 10 00 41 00 00 00 41 00 00 10 41 00
>e41c	00 20 41 00 00 31 41 00 00 41 41 00 00 41 31 00
>e42c	00 41 20 00 00 41 10 00 00 41 00 00 10 41 00 00
>e43c	20 41 00 00 31 41 00 00 41 41 00 00 41 31 00 00
>e44c	41 20 00 00 41 10 00 00 41 20 20 00 41 20 28 00
>e45c	41 20 31 00 41 20 39 00 41 20 41 00 39 20 41 00
>e46c	31 20 41 00 28 20 41 00 20 20 41 00 20 28 41 00
>e47c	20 31 41 00 20 39 41 00 20 41 41 00 20 41 39 00
>e48c	20 41 31 00 20 41 28 00 20 41 20 00 28 41 20 00
>e49c	31 41 20 00 39 41 20 00 41 41 20 00 41 39 20 00
>e4ac	41 31 20 00 41 28 20 00 41 2d 2d 00 41 2d 31 00
>e4bc	41 2d 35 00 41 2d 3d 00 41 2d 41 00 3d 2d 41 00
>e4cc	35 2d 41 00 31 2d 41 00 2d 2d 41 00 2d 31 41 00
>e4dc	2d 35 41 00 2d 3d 41 00 2d 41 41 00 2d 41 3d 00
>e4ec	2d 41 35 00 2d 41 31 00 2d 41 2d 00 31 41 2d 00
>e4fc	35 41 2d 00 3d 41 2d 00 41 41 2d 00 41 3d 2d 00
>e50c	41 35 2d 00 41 31 2d 00 00 00 00 00 00 00 00 00
>e51c	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
>e52c	00 00 00 00 00 00 00 00

;******  Return to file: newmonitor.asm


;******  Processing file: include/ps2convert.inc

.e534					ASCIIFromScanCode:
>e534	00					.byte	$00 ; $00
>e535	00					.byte	$00 ; $01
>e536	00					.byte	$00 ; $02
>e537	00					.byte	$00 ; $03
>e538	00					.byte	$00 ; $04
>e539	00					.byte	$00 ; $05
>e53a	00					.byte	$00 ; $06
>e53b	00					.byte	$00 ; $07
>e53c	00					.byte	$00 ; $08
>e53d	00					.byte	$00 ; $09
>e53e	00					.byte	$00 ; $0a
>e53f	00					.byte	$00 ; $0b
>e540	00					.byte	$00 ; $0c
>e541	09					.byte	$09 ; $0d chr$(9)
>e542	60					.byte	$60 ; $0e '`'
>e543	00					.byte	$00 ; $0f
>e544	00					.byte	$00 ; $10
>e545	00					.byte	$00 ; $11
>e546	00					.byte	$00 ; $12
>e547	00					.byte	$00 ; $13
>e548	00					.byte	$00 ; $14
>e549	71					.byte	$71 ; $15 'q'
>e54a	31					.byte	$31 ; $16 '1'
>e54b	00					.byte	$00 ; $17
>e54c	00					.byte	$00 ; $18
>e54d	00					.byte	$00 ; $19
>e54e	7a					.byte	$7a ; $1a 'z'
>e54f	73					.byte	$73 ; $1b 's'
>e550	61					.byte	$61 ; $1c 'a'
>e551	77					.byte	$77 ; $1d 'w'
>e552	32					.byte	$32 ; $1e '2'
>e553	00					.byte	$00 ; $1f
>e554	00					.byte	$00 ; $20
>e555	63					.byte	$63 ; $21 'c'
>e556	78					.byte	$78 ; $22 'x'
>e557	64					.byte	$64 ; $23 'd'
>e558	65					.byte	$65 ; $24 'e'
>e559	34					.byte	$34 ; $25 '4'
>e55a	33					.byte	$33 ; $26 '3'
>e55b	00					.byte	$00 ; $27
>e55c	00					.byte	$00 ; $28
>e55d	20					.byte	$20 ; $29 ' '
>e55e	76					.byte	$76 ; $2a 'v'
>e55f	66					.byte	$66 ; $2b 'f'
>e560	74					.byte	$74 ; $2c 't'
>e561	72					.byte	$72 ; $2d 'r'
>e562	35					.byte	$35 ; $2e '5'
>e563	00					.byte	$00 ; $2f
>e564	00					.byte	$00 ; $30
>e565	6e					.byte	$6e ; $31 'n'
>e566	62					.byte	$62 ; $32 'b'
>e567	68					.byte	$68 ; $33 'h'
>e568	67					.byte	$67 ; $34 'g'
>e569	79					.byte	$79 ; $35 'y'
>e56a	36					.byte	$36 ; $36 '6'
>e56b	00					.byte	$00 ; $37
>e56c	00					.byte	$00 ; $38
>e56d	00					.byte	$00 ; $39
>e56e	6d					.byte	$6d ; $3a 'm'
>e56f	6a					.byte	$6a ; $3b 'j'
>e570	75					.byte	$75 ; $3c 'u'
>e571	37					.byte	$37 ; $3d '7'
>e572	38					.byte	$38 ; $3e '8'
>e573	00					.byte	$00 ; $3f
>e574	00					.byte	$00 ; $40
>e575	2c					.byte	$2c ; $41 ','
>e576	6b					.byte	$6b ; $42 'k'
>e577	69					.byte	$69 ; $43 'i'
>e578	6f					.byte	$6f ; $44 'o'
>e579	30					.byte	$30 ; $45 '0'
>e57a	39					.byte	$39 ; $46 '9'
>e57b	00					.byte	$00 ; $47
>e57c	00					.byte	$00 ; $48
>e57d	2e					.byte	$2e ; $49 '.'
>e57e	2f					.byte	$2f ; $4a '/'
>e57f	6c					.byte	$6c ; $4b 'l'
>e580	3b					.byte	$3b ; $4c ';'
>e581	70					.byte	$70 ; $4d 'p'
>e582	2d					.byte	$2d ; $4e '-'
>e583	00					.byte	$00 ; $4f
>e584	00					.byte	$00 ; $50
>e585	00					.byte	$00 ; $51
>e586	27					.byte	$27 ; $52 '''
>e587	00					.byte	$00 ; $53
>e588	5b					.byte	$5b ; $54 '['
>e589	3d					.byte	$3d ; $55 '='
>e58a	00					.byte	$00 ; $56
>e58b	00					.byte	$00 ; $57
>e58c	00					.byte	$00 ; $58
>e58d	00					.byte	$00 ; $59
>e58e	0d					.byte	$0d ; $5a chr$(13)
>e58f	5d					.byte	$5d ; $5b ']'
>e590	00					.byte	$00 ; $5c
>e591	7c					.byte	$7c ; $5d '|'
>e592	00					.byte	$00 ; $5e
>e593	00					.byte	$00 ; $5f
>e594	00					.byte	$00 ; $60
>e595	00					.byte	$00 ; $61
>e596	00					.byte	$00 ; $62
>e597	00					.byte	$00 ; $63
>e598	00					.byte	$00 ; $64
>e599	00					.byte	$00 ; $65
>e59a	08					.byte	$08 ; $66 chr$(8)
>e59b	00					.byte	$00 ; $67
>e59c	00					.byte	$00 ; $68
>e59d	00					.byte	$00 ; $69
>e59e	00					.byte	$00 ; $6a
>e59f	02					.byte	$02 ; $6b chr$(2)
>e5a0	00					.byte	$00 ; $6c
>e5a1	00					.byte	$00 ; $6d
>e5a2	00					.byte	$00 ; $6e
>e5a3	00					.byte	$00 ; $6f
>e5a4	00					.byte	$00 ; $70
>e5a5	00					.byte	$00 ; $71
>e5a6	0e					.byte	$0e ; $72 chr$(14)
>e5a7	00					.byte	$00 ; $73
>e5a8	06					.byte	$06 ; $74 chr$(6)
>e5a9	10					.byte	$10 ; $75 chr$(16)
>e5aa	1b					.byte	$1b ; $76 chr$(27)
>e5ab	00					.byte	$00 ; $77
>e5ac	00					.byte	$00 ; $78
>e5ad	00					.byte	$00 ; $79
>e5ae	00					.byte	$00 ; $7a
>e5af	00					.byte	$00 ; $7b
>e5b0	00					.byte	$00 ; $7c
>e5b1	00					.byte	$00 ; $7d
>e5b2	00					.byte	$00 ; $7e
>e5b3	00					.byte	$00 ; $7f
>e5b4	00					.byte	$00 ; $80
>e5b5	00					.byte	$00 ; $81
>e5b6	00					.byte	$00 ; $82
>e5b7	00					.byte	$00 ; $83
>e5b8	00					.byte	$00 ; $84
>e5b9	00					.byte	$00 ; $85
>e5ba	00					.byte	$00 ; $86
>e5bb	00					.byte	$00 ; $87
>e5bc	00					.byte	$00 ; $88
>e5bd	00					.byte	$00 ; $89
>e5be	00					.byte	$00 ; $8a
>e5bf	00					.byte	$00 ; $8b
>e5c0	00					.byte	$00 ; $8c
>e5c1	00					.byte	$00 ; $8d
>e5c2	00					.byte	$00 ; $8e
>e5c3	00					.byte	$00 ; $8f
>e5c4	00					.byte	$00 ; $90
>e5c5	00					.byte	$00 ; $91
>e5c6	00					.byte	$00 ; $92
>e5c7	00					.byte	$00 ; $93
>e5c8	00					.byte	$00 ; $94
>e5c9	00					.byte	$00 ; $95
>e5ca	00					.byte	$00 ; $96
>e5cb	00					.byte	$00 ; $97
>e5cc	00					.byte	$00 ; $98
>e5cd	00					.byte	$00 ; $99
>e5ce	00					.byte	$00 ; $9a
>e5cf	00					.byte	$00 ; $9b
>e5d0	00					.byte	$00 ; $9c
>e5d1	00					.byte	$00 ; $9d
>e5d2	00					.byte	$00 ; $9e
>e5d3	00					.byte	$00 ; $9f
>e5d4	00					.byte	$00 ; $a0
>e5d5	00					.byte	$00 ; $a1
>e5d6	00					.byte	$00 ; $a2
>e5d7	00					.byte	$00 ; $a3
>e5d8	00					.byte	$00 ; $a4
>e5d9	00					.byte	$00 ; $a5
>e5da	00					.byte	$00 ; $a6
>e5db	00					.byte	$00 ; $a7
>e5dc	00					.byte	$00 ; $a8
>e5dd	00					.byte	$00 ; $a9
>e5de	00					.byte	$00 ; $aa
>e5df	00					.byte	$00 ; $ab
>e5e0	00					.byte	$00 ; $ac
>e5e1	00					.byte	$00 ; $ad
>e5e2	00					.byte	$00 ; $ae
>e5e3	00					.byte	$00 ; $af
>e5e4	00					.byte	$00 ; $b0
>e5e5	00					.byte	$00 ; $b1
>e5e6	00					.byte	$00 ; $b2
>e5e7	00					.byte	$00 ; $b3
>e5e8	00					.byte	$00 ; $b4
>e5e9	00					.byte	$00 ; $b5
>e5ea	00					.byte	$00 ; $b6
>e5eb	00					.byte	$00 ; $b7
>e5ec	00					.byte	$00 ; $b8
>e5ed	00					.byte	$00 ; $b9
>e5ee	00					.byte	$00 ; $ba
>e5ef	00					.byte	$00 ; $bb
>e5f0	00					.byte	$00 ; $bc
>e5f1	00					.byte	$00 ; $bd
>e5f2	00					.byte	$00 ; $be
>e5f3	00					.byte	$00 ; $bf
>e5f4	00					.byte	$00 ; $c0
>e5f5	00					.byte	$00 ; $c1
>e5f6	00					.byte	$00 ; $c2
>e5f7	00					.byte	$00 ; $c3
>e5f8	00					.byte	$00 ; $c4
>e5f9	00					.byte	$00 ; $c5
>e5fa	00					.byte	$00 ; $c6
>e5fb	00					.byte	$00 ; $c7
>e5fc	00					.byte	$00 ; $c8
>e5fd	00					.byte	$00 ; $c9
>e5fe	00					.byte	$00 ; $ca
>e5ff	00					.byte	$00 ; $cb
>e600	00					.byte	$00 ; $cc
>e601	00					.byte	$00 ; $cd
>e602	00					.byte	$00 ; $ce
>e603	00					.byte	$00 ; $cf
>e604	00					.byte	$00 ; $d0
>e605	00					.byte	$00 ; $d1
>e606	00					.byte	$00 ; $d2
>e607	00					.byte	$00 ; $d3
>e608	00					.byte	$00 ; $d4
>e609	00					.byte	$00 ; $d5
>e60a	00					.byte	$00 ; $d6
>e60b	00					.byte	$00 ; $d7
>e60c	00					.byte	$00 ; $d8
>e60d	00					.byte	$00 ; $d9
>e60e	00					.byte	$00 ; $da
>e60f	00					.byte	$00 ; $db
>e610	00					.byte	$00 ; $dc
>e611	00					.byte	$00 ; $dd
>e612	00					.byte	$00 ; $de
>e613	00					.byte	$00 ; $df
>e614	00					.byte	$00 ; $e0
>e615	00					.byte	$00 ; $e1
>e616	00					.byte	$00 ; $e2
>e617	00					.byte	$00 ; $e3
>e618	00					.byte	$00 ; $e4
>e619	00					.byte	$00 ; $e5
>e61a	00					.byte	$00 ; $e6
>e61b	00					.byte	$00 ; $e7
>e61c	00					.byte	$00 ; $e8
>e61d	05					.byte	$05 ; $e9 chr$(5)
>e61e	00					.byte	$00 ; $ea
>e61f	02					.byte	$02 ; $eb chr$(2)
>e620	01					.byte	$01 ; $ec chr$(1)
>e621	00					.byte	$00 ; $ed
>e622	00					.byte	$00 ; $ee
>e623	00					.byte	$00 ; $ef
>e624	00					.byte	$00 ; $f0
>e625	04					.byte	$04 ; $f1 chr$(4)
>e626	0e					.byte	$0e ; $f2 chr$(14)
>e627	00					.byte	$00 ; $f3
>e628	06					.byte	$06 ; $f4 chr$(6)
>e629	10					.byte	$10 ; $f5 chr$(16)
>e62a	00					.byte	$00 ; $f6
>e62b	00					.byte	$00 ; $f7
>e62c	00					.byte	$00 ; $f8
>e62d	00					.byte	$00 ; $f9
>e62e	00					.byte	$00 ; $fa
>e62f	00					.byte	$00 ; $fb
>e630	00					.byte	$00 ; $fc
>e631	00					.byte	$00 ; $fd
>e632	00					.byte	$00 ; $fe
>e633	00					.byte	$00 ; $ff
>e634	ff					.byte	$FF
.e635					ShiftFixTable:
>e635	60 7e					.byte	$60,$7e		; ` => ~
>e637	31 21					.byte	$31,$21		; 1 => !
>e639	32 40					.byte	$32,$40		; 2 => @
>e63b	33 23					.byte	$33,$23		; 3 => #
>e63d	34 24					.byte	$34,$24		; 4 => $
>e63f	35 25					.byte	$35,$25		; 5 => %
>e641	36 5e					.byte	$36,$5e		; 6 => ^
>e643	37 26					.byte	$37,$26		; 7 => &
>e645	38 2a					.byte	$38,$2a		; 8 => *
>e647	39 28					.byte	$39,$28		; 9 => (
>e649	30 29					.byte	$30,$29		; 0 => )
>e64b	2d 5f					.byte	$2d,$5f		; - => _
>e64d	3d 2b					.byte	$3d,$2b		; = => +
>e64f	3b 3a					.byte	$3b,$3a		; ; => :
>e651	27 22					.byte	$27,$22		; ' => "
>e653	2c 3c					.byte	$2c,$3c		; , => <
>e655	2e 3e					.byte	$2e,$3e		; . => >
>e657	2f 3f					.byte	$2f,$3f		; / => ?
>e659	ff					.byte	$FF
=2					KP_LEFTCTRL_ROW = 2
=$10					KP_LEFTCTRL_COL = $10
=2					KP_LEFTSHIFT_ROW = 2
=$04					KP_LEFTSHIFT_COL = $04
=11					KP_RIGHTSHIFT_ROW = 11
=$02					KP_RIGHTSHIFT_COL = $02
=4					KP_C_ROW = 4
=$02					KP_C_COL = $02
=3					KP_Z_ROW = 3
=$04					KP_Z_COL = $04
=4					KP_X_ROW = 4
=$04					KP_X_COL = $04
=8					KP_K_ROW = 8
=$04					KP_K_COL = $04
=7					KP_M_ROW = 7
=$04					KP_M_COL = $04
=9					KP_L_ROW = 9
=$08					KP_L_COL = $08

;******  Return to file: newmonitor.asm


;******  Processing file: src/init_graphics_palettes.asm

.e65a					init_graphics_palettes
.e65a	da		phx		            phx
.e65b	5a		phy		            phy
.e65c	a4 01		ldy $01		            ldy     $1
.e65e	a9 01		lda #$01	            lda     #1
.e660	85 01		sta $01		            sta     $1
.e662	64 fc		stz $fc		            stz     zTemp0+0
.e664	a9 d0		lda #$d0	            lda     #$d0
.e666	85 fd		sta $fd		            sta     zTemp0+1
.e668	a2 00		ldx #$00	            ldx     #0          ; Starting color byte.
.e66a					_loop
.e66a	20 84 e6	jsr $e684	            jsr     write_bgra
.e66d	e8		inx		            inx
.e66e	a5 fc		lda $fc		            lda     zTemp0
.e670	69 04		adc #$04	            adc     #4
.e672	85 fc		sta $fc		            sta     zTemp0
.e674	d0 f4		bne $e66a	            bne     _loop
.e676	a5 fd		lda $fd		            lda     zTemp0+1
.e678	1a		inc a		            inc     a
.e679	85 fd		sta $fd		            sta     zTemp0+1
.e67b	c9 e0		cmp #$e0	            cmp     #$e0
.e67d	d0 eb		bne $e66a	            bne     _loop
.e67f	84 01		sty $01		            sty     $1
.e681	7a		ply		            ply
.e682	fa		plx		            plx
.e683	60		rts		            rts
.e684					write_bgra
.e684	5a		phy		            phy
.e685	a0 03		ldy #$03	            ldy     #3  ; Working backwards: A,R,G,B
.e687	a9 ff		lda #$ff	            lda     #255
.e689	20 98 e6	jsr $e698	            jsr     _write
.e68c	8a		txa		            txa
.e68d	88		dey		_loop       dey
.e68e	30 05		bmi $e695	            bmi     _done
.e690	20 98 e6	jsr $e698	            jsr     _write
.e693	80 f8		bra $e68d	            bra     _loop
.e695	7a		ply		_done       ply
.e696	18		clc		            clc
.e697	60		rts		            rts
.e698					_write
.e698	48		pha		            pha
.e699	29 e0		and #$e0	            and     #%111_00000
.e69b	91 fc		sta ($fc),y	            sta     (zTemp0),y
.e69d	68		pla		            pla
.e69e	0a		asl a		            asl     a
.e69f	0a		asl a		            asl     a
.e6a0	0a		asl a		            asl     a
.e6a1	60		rts		            rts

;******  Return to file: newmonitor.asm

.e6a2					SelectPage0:
.e6a2	48		pha			pha
.e6a3	a5 01		lda $01			lda 	IOPageRegister
.e6a5	29 fc		and #$fc		and 	#$FC
.e6a7					SelectPageWrite:
.e6a7	85 01		sta $01			sta 	IOPageRegister
.e6a9	8d 06 02	sta $0206		sta 	CurrentPage
.e6ac	68		pla			pla
.e6ad	60		rts			rts
.e6ae					SelectPage1:
.e6ae	48		pha			pha
.e6af	a5 01		lda $01			lda 	IOPageRegister
.e6b1	29 fc		and #$fc		and 	#$FC
.e6b3	09 01		ora #$01		ora 	#1
.e6b5	80 f0		bra $e6a7		bra 	SelectPageWrite
.e6b7					SelectPage2:
.e6b7	48		pha			pha
.e6b8	a5 01		lda $01			lda 	IOPageRegister
.e6ba	29 fc		and #$fc		and 	#$FC
.e6bc	09 02		ora #$02		ora 	#2
.e6be	80 e7		bra $e6a7		bra 	SelectPageWrite
.e6c0					SelectPage3:
.e6c0	48		pha			pha
.e6c1	a5 01		lda $01			lda 	IOPageRegister
.e6c3	09 03		ora #$03		ora 	#3
.e6c5	80 e0		bra $e6a7		bra 	SelectPageWrite
.e6c7					ClearScreen:
.e6c7	da		phx			phx
.e6c8	20 c0 e6	jsr $e6c0		jsr 	SelectPage3
.e6cb	ad 05 02	lda $0205		lda 	TextColour
.e6ce	20 db e6	jsr $e6db		jsr 	_ScreenFill
.e6d1	20 b7 e6	jsr $e6b7		jsr 	SelectPage2
.e6d4	a9 20		lda #$20		lda 	#$20
.e6d6	20 db e6	jsr $e6db		jsr 	_ScreenFill
.e6d9	fa		plx			plx
.e6da	60		rts			rts
.e6db					_ScreenFill:
.e6db	48		pha			pha
.e6dc	a9 c0		lda #$c0		lda 	#$C0 								; fill D000-D7FF with $60
.e6de	85 fd		sta $fd			sta 	zTemp0+1
.e6e0	a9 00		lda #$00		lda 	#$00
.e6e2	85 fc		sta $fc			sta 	zTemp0
.e6e4	a0 00		ldy #$00		ldy 	#0
.e6e6	68		pla			pla
.e6e7					_CLSLoop:
.e6e7	91 fc		sta ($fc),y		sta 	(zTemp0),y
.e6e9	c8		iny			iny
.e6ea	d0 fb		bne $e6e7		bne 	_CLSLoop
.e6ec	e6 fd		inc $fd			inc 	zTemp0+1
.e6ee	a6 fd		ldx $fd			ldx 	zTemp0+1
.e6f0	e0 d3		cpx #$d3		cpx 	#$D3
.e6f2	d0 f3		bne $e6e7		bne 	_CLSLoop
.e6f4	20 a2 e6	jsr $e6a2		jsr 	SelectPage0
.e6f7					HomeCursor:
.e6f7	a9 00		lda #$00		lda 	#0
.e6f9	8d 03 02	sta $0203		sta 	xPosition
.e6fc	8d 04 02	sta $0204		sta 	yPosition
.e6ff	20 03 e7	jsr $e703		jsr 	UpdateCursor
.e702	60		rts			rts
.e703					UpdateCursor:
.e703	48		pha			pha
.e704	ad 03 02	lda $0203		lda 	xPosition
.e707	8d 14 d0	sta $d014		sta 	$D014
.e70a	ad 04 02	lda $0204		lda 	yPosition
.e70d	8d 16 d0	sta $d016		sta 	$D016
.e710	68		pla			pla
.e711	60		rts			rts
.e712					SetZTemp0CharPos:
.e712	48		pha			pha
.e713	8a		txa			txa
.e714	48		pha			pha
.e715	ad 04 02	lda $0204		lda 	yPosition 						; zTemp0 = yPos
.e718	85 fc		sta $fc			sta 	zTemp0
.e71a	a9 00		lda #$00		lda 	#0
.e71c	85 fd		sta $fd			sta 	zTemp0+1
.e71e	a2 06		ldx #$06		ldx 	#6 								; x 80
.e720					_SZ0Shift:
.e720	06 fc		asl $fc			asl 	zTemp0
.e722	26 fd		rol $fd			rol 	zTemp0+1
.e724	e0 05		cpx #$05		cpx 	#5
.e726	d0 0c		bne $e734		bne 	_SZ0NoAdd
.e728	18		clc			clc
.e729	a5 fc		lda $fc			lda 	zTemp0
.e72b	6d 04 02	adc $0204		adc 	yPosition
.e72e	85 fc		sta $fc			sta 	zTemp0
.e730	90 02		bcc $e734		bcc 	_SZ0NoAdd
.e732	e6 fd		inc $fd			inc 	zTemp0+1
.e734					_SZ0NoAdd:
.e734	ca		dex			dex
.e735	d0 e9		bne $e720		bne 	_SZ0Shift
.e737	18		clc			clc
.e738	a5 fc		lda $fc			lda 	zTemp0 							; add in xPos
.e73a	6d 03 02	adc $0203		adc 	xPosition
.e73d	85 fc		sta $fc			sta 	zTemp0
.e73f	a5 fd		lda $fd			lda 	zTemp0+1 						; point to page D
.e741	69 c0		adc #$c0		adc 	#$C0
.e743	85 fd		sta $fd			sta 	zTemp0+1
.e745	68		pla			pla
.e746	aa		tax			tax
.e747	68		pla			pla
.e748	60		rts			rts
.e749					PrintHex:
.e749	48		pha			pha
.e74a	a9 20		lda #$20		lda 	#32
.e74c	20 6c e7	jsr $e76c		jsr 	PrintCharacter
.e74f	68		pla			pla
.e750	48		pha			pha
.e751	48		pha			pha
.e752	4a		lsr a			lsr 	a
.e753	4a		lsr a			lsr 	a
.e754	4a		lsr a			lsr 	a
.e755	4a		lsr a			lsr 	a
.e756	20 5f e7	jsr $e75f		jsr 	PrintNibble
.e759	68		pla			pla
.e75a	20 5f e7	jsr $e75f		jsr 	PrintNibble
.e75d	68		pla			pla
.e75e	60		rts			rts
.e75f					PrintNibble:
.e75f	29 0f		and #$0f		and 	#15
.e761	c9 0a		cmp #$0a		cmp 	#10
.e763	90 02		bcc $e767		bcc 	_PN0
.e765	69 06		adc #$06		adc 	#6
.e767					_PN0:
.e767	69 30		adc #$30		adc 	#48
.e769	4c 6c e7	jmp $e76c		jmp 	PrintCharacter
.e76c					PrintCharacter:
.e76c	48		pha			pha
.e76d	da		phx			phx
.e76e	5a		phy			phy
.e76f	a6 01		ldx $01			ldx 	1
.e771	da		phx			phx
.e772	20 b7 e6	jsr $e6b7		jsr 	SelectPage2
.e775	48		pha			pha
.e776	c9 08		cmp #$08		cmp 	#8
.e778	f0 51		beq $e7cb		beq 	_PCBackspace
.e77a	c9 09		cmp #$09		cmp 	#9
.e77c	f0 3f		beq $e7bd		beq 	_PCTab
.e77e	c9 0d		cmp #$0d		cmp 	#13
.e780	f0 5a		beq $e7dc		beq 	_PCCRLF
.e782	20 12 e7	jsr $e712		jsr 	SetZTemp0CharPos 				; all other characters
.e785	92 fc		sta ($fc)		sta 	(zTemp0)
.e787	20 c0 e6	jsr $e6c0		jsr 	SelectPage3
.e78a	ad 05 02	lda $0205		lda 	TextColour
.e78d	92 fc		sta ($fc)		sta 	(zTemp0)
.e78f	20 b7 e6	jsr $e6b7		jsr 	SelectPage2
.e792	ee 03 02	inc $0203		inc 	xPosition
.e795	ad 03 02	lda $0203		lda 	xPosition
.e798	c9 50		cmp #$50		cmp  	#CWidth
.e79a	d0 13		bne $e7af		bne 	_PCNotRight
.e79c	9c 03 02	stz $0203		stz 	xPosition
.e79f	ee 04 02	inc $0204		inc 	yPosition
.e7a2	ad 04 02	lda $0204		lda 	yPosition
.e7a5	c9 3c		cmp #$3c		cmp 	#CHeight
.e7a7	d0 06		bne $e7af		bne 	_PCNotRight
.e7a9	ce 04 02	dec $0204		dec 	yPosition
.e7ac	20 e9 e7	jsr $e7e9		jsr 	ScrollScreenUp
.e7af					_PCNotRight:
.e7af	20 a2 e6	jsr $e6a2		jsr 	SelectPage0
.e7b2	20 03 e7	jsr $e703		jsr 	UpdateCursor
.e7b5	68		pla			pla
.e7b6	fa		plx			plx
.e7b7	86 01		stx $01			stx 	1
.e7b9	7a		ply			ply
.e7ba	fa		plx			plx
.e7bb	68		pla			pla
.e7bc	60		rts			rts
.e7bd					_PCTab:
.e7bd	a9 20		lda #$20		lda 	#' '
.e7bf	20 6c e7	jsr $e76c		jsr 	PrintCharacter
.e7c2	ad 03 02	lda $0203		lda 	xPosition
.e7c5	29 07		and #$07		and 	#7
.e7c7	d0 f4		bne $e7bd		bne 	_PCTab
.e7c9	80 e4		bra $e7af		bra 	_PCNotRight
.e7cb					_PCBackspace:
.e7cb	ad 03 02	lda $0203		lda 	xPosition
.e7ce	f0 df		beq $e7af		beq 	_PCNotRight
.e7d0	ce 03 02	dec $0203		dec 	xPosition
.e7d3	20 12 e7	jsr $e712		jsr 	SetZTemp0CharPos
.e7d6	a9 20		lda #$20		lda 	#' '
.e7d8	92 fc		sta ($fc)		sta 	(zTemp0)
.e7da	80 d3		bra $e7af		bra 	_PCNotRight
.e7dc					_PCCRLF:
.e7dc	a9 20		lda #$20		lda 	#$20 							; fill with EOL $20
.e7de	20 6c e7	jsr $e76c		jsr 	PrintCharacter
.e7e1	ad 03 02	lda $0203		lda 	xPosition 						; until back at left
.e7e4	d0 f6		bne $e7dc		bne 	_PCCRLF
.e7e6	80 c7		bra $e7af		bra 	_PCNotRight
.e7e8					NMIHandler:
.e7e8	40		rti				rti
.e7e9					ScrollScreenUp:
.e7e9	98		tya			tya
.e7ea	48		pha			pha
.e7eb	20 c0 e6	jsr $e6c0		jsr 	SelectPage3
.e7ee	20 17 e8	jsr $e817		jsr 	_ScrollBank
.e7f1	ad 05 02	lda $0205		lda 	TextColour
.e7f4	20 05 e8	jsr $e805		jsr 	_WriteBottomLine
.e7f7	20 b7 e6	jsr $e6b7		jsr 	SelectPage2
.e7fa	20 17 e8	jsr $e817		jsr 	_ScrollBank
.e7fd	a9 20		lda #$20		lda 	#32
.e7ff	20 05 e8	jsr $e805		jsr 	_WriteBottomLine
.e802	68		pla			pla
.e803	a8		tay			tay
.e804	60		rts			rts
.e805					_WriteBottomLine
.e805	48		pha			pha
.e806	a9 70		lda #$70		lda 	#$70
.e808	85 fc		sta $fc			sta 	zTemp0
.e80a	a9 d2		lda #$d2		lda 	#$D2
.e80c	85 fd		sta $fd			sta 	zTemp0+1
.e80e	a0 4f		ldy #$4f		ldy 	#CWidth-1
.e810	68		pla			pla
.e811					_ScrollBottomLine:
.e811	91 fc		sta ($fc),y		sta 	(zTemp0),y
.e813	88		dey			dey
.e814	10 fb		bpl $e811		bpl 	_ScrollBottomLine
.e816	60		rts			rts
.e817					_ScrollBank
.e817	a9 c0		lda #$c0		lda 	#$C0
.e819	85 fd		sta $fd			sta 	zTemp0+1
.e81b	a9 00		lda #$00		lda 	#$00
.e81d	85 fc		sta $fc			sta 	zTemp0
.e81f	a0 50		ldy #$50		ldy 	#CWidth
.e821					_ScrollLoop:
.e821	b1 fc		lda ($fc),y		lda 	(zTemp0),y
.e823	92 fc		sta ($fc)		sta 	(zTemp0)
.e825	e6 fc		inc $fc			inc 	zTemp0
.e827	d0 f8		bne $e821		bne 	_ScrollLoop
.e829	e6 fd		inc $fd			inc 	zTemp0+1
.e82b	a5 fd		lda $fd			lda 	zTemp0+1
.e82d	c9 d3		cmp #$d3		cmp 	#$D3
.e82f	d0 f0		bne $e821		bne 	_ScrollLoop
.e831	60		rts			rts
.e832					ControlCCheck:
.e832	ad 12 02	lda $0212		lda 	KeyStatus+KP_LEFTCTRL_ROW	; check LCtrl pressed
.e835	29 10		and #$10		and 	#KP_LEFTCTRL_COL
.e837	f0 08		beq $e841		beq 	Exit2
.e839	ad 14 02	lda $0214		lda 	KeyStatus+KP_C_ROW 			; check C pressed
.e83c	29 02		and #$02		and 	#KP_C_COL 					; non-zero if so
.e83e	49 02		eor #$02		eor 	#KP_C_COL 			 		; Z set if so.
.e840	60		rts			rts
.e841					Exit2:
.e841	a9 ff		lda #$ff		lda 	#$FF 						; NZ set
.e843	60		rts			rts
.e844					HandleKeyboard:
.e844	48		pha				pha
.e845	da		phx				phx
.e846	5a		phy				phy
.e847	c9 80		cmp #$80			cmp 	#$80 							; E0 (Scan shift)
.e849	90 14		bcc $e85f			bcc 	_KeyBit 						; if 00-7F then it is a keystroke.
.e84b	c9 e0		cmp #$e0			cmp 	#$E0
.e84d	f0 09		beq $e858			beq 	_HKIsShift 						; if = $E0 then it is a shifted key on the keyboard.
.e84f	c9 f0		cmp #$f0			cmp 	#$F0 							; if = $F0 then it is a release.
.e851	d0 48		bne $e89b			bne 	_HKExit
.e853	8d 08 02	sta $0208			sta 	ReleaseFlag 					; set release flag to non-zero.
.e856	80 43		bra $e89b			bra 	_HKExit
.e858					_HKIsShift:
.e858	a9 80		lda #$80			lda 	#$80 							; set scan shift flag to $80
.e85a	8d 09 02	sta $0209			sta 	ScanShiftFlag
.e85d	80 3c		bra $e89b			bra 	_HKExit
.e85f					_KeyBit:
.e85f	0d 09 02	ora $0209			ora 	ScanShiftFlag 					; A now contains the scan shift flag.
.e862	8d 09 02	sta $0209			sta 	ScanShiftFlag 					; store result there
.e865	29 7f		and #$7f			and 	#$7F
.e867	4a		lsr a				lsr 	a 								; divide by 8 -> X, offset in table
.e868	4a		lsr a				lsr 	a
.e869	4a		lsr a				lsr 	a
.e86a	aa		tax				tax
.e86b	ad 09 02	lda $0209			lda 	ScanShiftFlag 					; get the key press back.
.e86e	29 07		and #$07			and 	#7 								; count in Y
.e870	a8		tay				tay
.e871	a9 00		lda #$00			lda 	#0
.e873	38		sec				sec
.e874					_HKGetBits:
.e874	2a		rol a				rol 	a
.e875	88		dey				dey
.e876	10 fc		bpl $e874			bpl 	_HKGetBits
.e878	ac 08 02	ldy $0208			ldy 	ReleaseFlag 					; is the release flag set
.e87b	d0 05		bne $e882			bne 	_HKRelease
.e87d	1d 10 02	ora $0210,x			ora 	KeyStatus,x  					; set bit
.e880	80 05		bra $e887			bra 	_HKWrite
.e882					_HKRelease:
.e882	49 ff		eor #$ff			eor 	#$FF 							; clear bit
.e884	3d 10 02	and $0210,x			and 	KeyStatus,x
.e887					_HKWrite:
.e887	9d 10 02	sta $0210,x			sta 	KeyStatus,x
.e88a	ad 09 02	lda $0209			lda 	ScanShiftFlag 					; restore new code
.e88d	ae 08 02	ldx $0208			ldx 	ReleaseFlag
.e890	d0 03		bne $e895			bne 	_HKNotInsert 					; process key down
.e892	20 9f e8	jsr $e89f			jsr 	ConvertInsertKey
.e895					_HKNotInsert:
.e895	9c 08 02	stz $0208			stz 	ReleaseFlag 					; zero both flags.
.e898	9c 09 02	stz $0209			stz 	ScanShiftFlag
.e89b					_HKExit:
.e89b	7a		ply				ply
.e89c	fa		plx				plx
.e89d	68		pla				pla
.e89e	60		rts				rts
.e89f					ConvertInsertKey:
.e89f	aa		tax				tax 								; scan code in X
.e8a0	bd 34 e5	lda $e534,x			lda 	ASCIIFromScanCode,x 		; get ASCII unshifted
.e8a3	f0 39		beq $e8de			beq 	_CIKExit 					; key not known
.e8a5	a8		tay				tay 								; save in Y
.e8a6	30 2a		bmi $e8d2			bmi 	_CIKEndShiftCheck 			; if bit 7 was set shift doesn't affect this.
.e8a8	ad 12 02	lda $0212			lda 	KeyStatus+KP_LEFTSHIFT_ROW	; check left shift
.e8ab	29 04		and #$04			and 	#KP_LEFTSHIFT_COL
.e8ad	d0 07		bne $e8b6			bne 	_CIKShift
.e8af	ad 1b 02	lda $021b			lda 	KeyStatus+KP_RIGHTSHIFT_ROW	; check right shift
.e8b2	29 02		and #$02			and 	#KP_RIGHTSHIFT_COL
.e8b4	f0 1c		beq $e8d2			beq 	_CIKEndShiftCheck
.e8b6					_CIKShift:
.e8b6	a2 fe		ldx #$fe			ldx 	#254 						; check shift table.
.e8b8					_CIKShiftNext:
.e8b8	e8		inx				inx
.e8b9	e8		inx				inx
.e8ba	3c 35 e6	bit $e635,x			bit  	ShiftFixTable,x 			; end of table ?
.e8bd	30 0b		bmi $e8ca			bmi 	_CIDefaultShift
.e8bf	98		tya				tya 								; found a match ?
.e8c0	dd 35 e6	cmp $e635,x			cmp 	ShiftFixTable,x
.e8c3	d0 f3		bne $e8b8			bne 	_CIKShiftNext
.e8c5	bc 36 e6	ldy $e636,x			ldy 	ShiftFixTable+1,x 			; get replacement
.e8c8	80 08		bra $e8d2			bra 	_CIKEndShiftCheck
.e8ca					_CIDefaultShift:
.e8ca	c9 20		cmp #$20			cmp 	#32
.e8cc	90 04		bcc $e8d2			bcc 	_CIKEndShiftCheck
.e8ce	98		tya				tya 								; default shift.
.e8cf	49 20		eor #$20			eor 	#32
.e8d1	a8		tay				tay
.e8d2					_CIKEndShiftCheck:
.e8d2	ad 12 02	lda $0212			lda 	KeyStatus+KP_LEFTCTRL_ROW	; check LCtrl pressed
.e8d5	29 10		and #$10			and 	#KP_LEFTCTRL_COL
.e8d7	f0 04		beq $e8dd			beq 	_CIKNotControl
.e8d9	98		tya				tya 								; lower 5 bits only on control.
.e8da	29 1f		and #$1f			and 	#31
.e8dc	a8		tay				tay
.e8dd					_CIKNotControl:
.e8dd	98		tya				tya
.e8de					_CIKExit:
.e8de	ac 07 02	ldy $0207			ldy 	KeysInQueue 				; space in queue ?
.e8e1	c0 08		cpy #$08			cpy 	#KQSize
.e8e3	f0 06		beq $e8eb			beq 	_CIKQueueFull
.e8e5	99 30 02	sta $0230,y			sta 	KeyboardQueue,y 			; write to queue.
.e8e8	ee 07 02	inc $0207			inc 	KeysInQueue
.e8eb					_CIKQueueFull:
.e8eb	60		rts				rts
.e8ec					NewReadKeyboard:
.e8ec	20 fd e8	jsr $e8fd			jsr 	GetKeyIfPressed
.e8ef	f0 fb		beq $e8ec			beq 	NewReadKeyboard
.e8f1	60		rts				rts
.e8f2					FakeKeyboardRead:
.e8f2	20 ec e8	jsr $e8ec			jsr 	NewReadKeyboard 			; echo everything except CR, makes
.e8f5	c9 0d		cmp #$0d			cmp 	#13 						; it behave like the C64 with it's
.e8f7	f0 03		beq $e8fc			beq 	_FKRExit 					; line editing
.e8f9	20 6c e7	jsr $e76c			jsr 	PrintCharacter
.e8fc					_FKRExit:
.e8fc	60		rts				rts
.e8fd					GetKeyIfPressed:
.e8fd	ad 07 02	lda $0207			lda 	KeysInQueue 				; anything in queue
.e900	f0 17		beq $e919			beq 	_GIKExit 					; if not, exit with A = 0, Z set
.e902	ad 30 02	lda $0230			lda 	KeyboardQueue 				; get and push front of queue
.e905	48		pha				pha
.e906	da		phx				phx
.e907	a2 00		ldx #$00			ldx 	#0 							; remove from queue
.e909					_GIKPop:
.e909	bd 31 02	lda $0231,x			lda 	KeyboardQueue+1,x
.e90c	9d 30 02	sta $0230,x			sta 	KeyboardQueue,x
.e90f	e8		inx				inx
.e910	e0 08		cpx #$08			cpx 	#KQSize
.e912	d0 f5		bne $e909			bne 	_GIKPop
.e914	ce 07 02	dec $0207			dec 	KeysInQueue 				; one fewer in queue
.e917	fa		plx				plx
.e918	68		pla				pla 								; restore front of queue setting Z
.e919					_GIKExit:
.e919	60		rts				rts
.e91a					SystemReset:
.e91a	a2 ff		ldx #$ff		ldx		#$FF
.e91c	9a		txs			txs
.e91d	78		sei			sei
.e91e	a9 80		lda #$80		lda 	#$80 								; access current LUT
.e920	85 00		sta $00			sta 	$00
.e922	a4 0f		ldy $0f			ldy 	15 									; get monitor page
.e924	a9 b0		lda #$b0		lda 	#$80+$30+$00 						; LUT 3 , Edit 3, Active 0
.e926	85 00		sta $00		 	sta 	$00
.e928	a2 05		ldx #$05		ldx 	#5 									; map all to memory.
.e92a					_InitMMU3:
.e92a	8a		txa			txa
.e92b	95 08		sta $08,x		sta 	8,x
.e92d	ca		dex			dex
.e92e	10 fa		bpl $e92a		bpl 	_InitMMU3
.e930	a9 1a		lda #$1a		lda 	#BASIC_ADDRESS >> 13 				; map BASIC ROM into slots 4 & 5, consecutive pages
.e932	85 0c		sta $0c			sta 	12
.e934	1a		inc a			inc 	a
.e935	85 0d		sta $0d			sta 	13
.e937	a9 06		lda #$06		lda 	#6 									; theoretically ; owned by Kernal.
.e939	85 0e		sta $0e			sta 	14
.e93b	84 0f		sty $0f			sty 	15 									; copy monitor page.
.e93d	a9 b3		lda #$b3		lda 	#$80+$30+$03 						; LUT 3 , Edit 3, Active 3
.e93f	85 00		sta $00			sta 	$00
.e941	a2 38		ldx #$38		ldx 	#EndWorkSpace-StartWorkSpace
.e943					_SRClear:
.e943	9e ff 01	stz $01ff,x		stz 	StartWorkSpace-1,x
.e946	ca		dex			dex
.e947	e0 ff		cpx #$ff		cpx 	#$FF
.e949	d0 f8		bne $e943		bne 	_SRClear
.e94b	20 a2 e6	jsr $e6a2		jsr 	SelectPage0
.e94e	a9 ff		lda #$ff	    LDA #$FF
.e950	8d 68 d6	sta $d668	    STA INT_EDGE_REG0
.e953	8d 69 d6	sta $d669	    STA INT_EDGE_REG1
.e956	8d 6c d6	sta $d66c	    STA INT_MASK_REG0
.e959	8d 6d d6	sta $d66d	    STA INT_MASK_REG1
.e95c	ad 60 d6	lda $d660	    lda INT_PENDING_REG0
.e95f	8d 60 d6	sta $d660	    sta INT_PENDING_REG0
.e962	ad 61 d6	lda $d661	    lda INT_PENDING_REG1
.e965	8d 61 d6	sta $d661	    sta INT_PENDING_REG1
.e968	64 01		stz $01		    stz 	$01
.e96a	ad 70 d6	lda $d670	    lda 	$D670
.e96d	48		pha		    pha
.e96e	20 00 e0	jsr $e000		jsr 	TinyVickyInitialise
.e971	20 49 e0	jsr $e049		jsr 	Init_Text_LUT
.e974	20 13 e1	jsr $e113		jsr 	LoadGraphicsLUT
.e977	20 c7 e6	jsr $e6c7		jsr 	ClearScreen
.e97a	ee 04 02	inc $0204		inc 	yPosition
.e97d	ee 04 02	inc $0204		inc 	yPosition
.e980	68		pla			pla
.e981	20 49 e7	jsr $e749		jsr 	PrintHex
.e984	a9 0d		lda #$0d		lda 	#13
.e986	20 6c e7	jsr $e76c		jsr 	PrintCharacter
.e989	a2 08		ldx #$08		ldx 	#8
.e98b					_ShowMMU:
.e98b	b5 00		lda $00,x		lda 	0,x
.e98d	20 49 e7	jsr $e749		jsr 	PrintHex
.e990	a9 20		lda #$20		lda 	#32
.e992	20 6c e7	jsr $e76c		jsr 	PrintCharacter
.e995	e8		inx			inx
.e996	e0 10		cpx #$10		cpx		#16
.e998	d0 f1		bne $e98b		bne 	_ShowMMU
.e99a	a9 0d		lda #$0d		lda 	#13
.e99c	20 6c e7	jsr $e76c		jsr 	PrintCharacter
.e99f	a2 00		ldx #$00		ldx 	#0
.e9a1	a5 0f		lda $0f			lda 	15
.e9a3	c9 3f		cmp #$3f		cmp 	#$3F
.e9a5	d0 02		bne $e9a9		bne 	_NotRAM
.e9a7	a2 11		ldx #$11		ldx 	#Prompt2-Prompt1
.e9a9					_NotRAM:
.e9a9	20 7f ea	jsr $ea7f		jsr 	PrintMsg
.e9ac	a2 26		ldx #$26		ldx 	#Prompt3-Prompt1
.e9ae	20 7f ea	jsr $ea7f		jsr 	PrintMsg
.e9b1	a9 c8		lda #$c8	    lda #200
.e9b3	8d 19 d0	sta $d019	    sta VKY_LINE_CMP_VALUE_LO
.e9b6	a9 00		lda #$00	    lda #0
.e9b8	8d 1a d0	sta $d01a	    sta VKY_LINE_CMP_VALUE_HI
.e9bb	a9 01		lda #$01	    lda #$01
.e9bd	8d 18 d0	sta $d018	    sta VKY_LINE_IRQ_CTRL_REG
.e9c0	78		sei		    SEI
.e9c1	ad 60 d6	lda $d660	    lda INT_PENDING_REG0  ; Read the Pending Register &
.e9c4	29 02		and #$02	    and #JR0_INT01_SOL
.e9c6	8d 60 d6	sta $d660	    sta INT_PENDING_REG0  ; Writing it back will clear the Active Bit
.e9c9	ad 6c d6	lda $d66c	    lda INT_MASK_REG0
.e9cc	29 fd		and #$fd	    and #~JR0_INT01_SOL
.e9ce	8d 6c d6	sta $d66c	    sta INT_MASK_REG0
.e9d1	ad 60 d6	lda $d660	    lda INT_PENDING_REG0  ; Read the Pending Register &
.e9d4	29 04		and #$04	    and #JR0_INT02_KBD
.e9d6	8d 60 d6	sta $d660	    sta INT_PENDING_REG0  ; Writing it back will clear the Active Bit
.e9d9	ad 6c d6	lda $d66c	    lda INT_MASK_REG0
.e9dc	29 fb		and #$fb	    and #~JR0_INT02_KBD
.e9de	8d 6c d6	sta $d66c	    sta INT_MASK_REG0
.e9e1	20 a2 e6	jsr $e6a2		jsr 	SelectPage0
.e9e4	a9 01		lda #$01		lda 	#1
.e9e6	8d 00 d1	sta $d100		sta 	$D100
.e9e9	9c 01 d1	stz $d101		stz 	$D101
.e9ec	9c 02 d1	stz $d102		stz 	$D102
.e9ef	9c 03 d1	stz $d103		stz 	$D103
.e9f2	ee 00 07	inc $0700		inc 	$700
.e9f5	ad 00 07	lda $0700		lda 	$700
.e9f8	29 0f		and #$0f		and 	#15
.e9fa	09 40		ora #$40		ora 	#64
.e9fc	20 d2 ff	jsr $ffd2		jsr 	$FFD2
.e9ff	20 d2 ff	jsr $ffd2		jsr 	$FFD2
.ea02	20 d2 ff	jsr $ffd2		jsr 	$FFD2
.ea05	20 bc ea	jsr $eabc		jsr 	init_text_palette
.ea08	20 5a e6	jsr $e65a		jsr 	init_graphics_palettes
.ea0b	a9 2a		lda #$2a		lda 	#42
.ea0d	20 d2 ff	jsr $ffd2		jsr 	$FFD2
.ea10	20 8b ea	jsr $ea8b		jsr 	InitStefanyPS2
.ea13	58		cli			cli
.ea14	20 7c ea	jsr $ea7c		jsr 	RunProgram
.ea17					Halt:
.ea17	80 fe		bra $ea17		bra 	Halt
.ea19					Prompt1:
>ea19	0d 52 75 6e 6e 69 6e 67			.text 	13,"Running in RAM",13,0
>ea21	20 69 6e 20 52 41 4d 0d 00
.ea2a					Prompt2:
>ea2a	0d 52 75 6e 6e 69 6e 67			.text 	13,"Running from Flash",13,0
>ea32	20 66 72 6f 6d 20 46 6c 61 73 68 0d 00
.ea3f					Prompt3:
>ea3f	0d 52 65 71 75 69 72 65			.text 	13,"Requires new PS/2 Interface : B or 13th Dec FPGA or later",13,13,0
>ea47	73 20 6e 65 77 20 50 53 2f 32 20 49 6e 74 65 72
>ea57	66 61 63 65 20 3a 20 42 20 6f 72 20 31 33 74 68
>ea67	20 44 65 63 20 46 50 47 41 20 6f 72 20 6c 61 74
>ea77	65 72 0d 0d 00
.ea7c					RunProgram:
.ea7c	6c f8 ff	jmp ($fff8)		jmp 	($FFF8)
.ea7f					PrintMsg:
.ea7f	bd 19 ea	lda $ea19,x		lda 	Prompt1,x
.ea82	e8		inx			inx
.ea83	20 6c e7	jsr $e76c		jsr 	PrintCharacter
.ea86	c9 00		cmp #$00		cmp 	#0
.ea88	d0 f5		bne $ea7f		bne 	PrintMsg
.ea8a	60		rts			rts
.ea8b					InitStefanyPS2:
.ea8b	64 01		stz $01				stz 	$01
.ea8d	a9 30		lda #$30			lda 	#$30 						; should reset the hardware
.ea8f	8d 40 d6	sta $d640			sta 	$D640
.ea92	9c 40 d6	stz $d640			stz 	$D640
.ea95	60		rts				rts
.ea96					EchoScanCodesStefany:
.ea96					_ESCSLoop:
.ea96	ad 44 d6	lda $d644			lda 	$D644 						; wait for FIFO not to be empty
.ea99	29 01		and #$01			and 	#1
.ea9b	d0 f9		bne $ea96			bne 	_ESCSLoop
.ea9d	ad 42 d6	lda $d642			lda 	$D642 						; read it in.
.eaa0	20 49 e7	jsr $e749			jsr 	PrintHex
.eaa3	80 f1		bra $ea96			bra 	_ESCSLoop
.eaa5					EchoLoop:
.eaa5	20 fd e8	jsr $e8fd		jsr 	GetKeyIfPressed
.eaa8	c9 00		cmp #$00		cmp 	#0
.eaaa	f0 f9		beq $eaa5		beq 	EchoLoop
.eaac	20 49 e7	jsr $e749		jsr 	PrintHex
.eaaf	20 6c e7	jsr $e76c		jsr 	PrintCharacter
.eab2	4c a5 ea	jmp $eaa5		jmp 	EchoLoop
.eab5					ReadKeyboardStatusTable:
.eab5	da		phx			phx
.eab6	aa		tax			tax
.eab7	bd 10 02	lda $0210,x		lda 	KeyStatus,x
.eaba	fa		plx			plx
.eabb	60		rts			rts
.eabc					init_text_palette
.eabc	64 01		stz $01					stz 	1
.eabe	a2 00		ldx #$00	            ldx     #0
.eac0	bd cf ea	lda $eacf,x	_loop       lda     _palette,x
.eac3	9d 00 d8	sta $d800,x	            sta     TEXT_LUT_FG,x
.eac6	9d 40 d8	sta $d840,x	            sta     TEXT_LUT_BG,x
.eac9	e8		inx		            inx
.eaca	e0 40		cpx #$40	            cpx     #64
.eacc	d0 f2		bne $eac0	            bne     _loop
.eace	60		rts		            rts
.eacf					_palette
>eacf	00 00 00 00			            .dword  $000000
>ead3	ff ff ff 00			            .dword  $ffffff
>ead7	00 00 88 00			            .dword  $880000
>eadb	ee ff aa 00			            .dword  $aaffee
>eadf	cc 44 cc 00			            .dword  $cc44cc
>eae3	55 cc 00 00			            .dword  $00cc55
>eae7	aa 00 00 00			            .dword  $0000aa
>eaeb	77 dd dd 00			            .dword  $dddd77
>eaef	55 88 dd 00			            .dword  $dd8855
>eaf3	00 44 66 00			            .dword  $664400
>eaf7	77 77 ff 00			            .dword  $ff7777
>eafb	33 33 33 00			            .dword  $333333
>eaff	77 77 77 00			            .dword  $777777
>eb03	66 ff aa 00			            .dword  $aaff66
>eb07	ff 88 00 00			            .dword  $0088ff
>eb0b	bb bb bb 00			            .dword  $bbbbbb
.eb0f					GetNextEvent:
.eb0f	20 fd e8	jsr $e8fd			jsr 	GetKeyIfPressed 				; is a key pressed
.eb12	c9 00		cmp #$00			cmp 	#0
.eb14	38		sec				sec
.eb15	f0 13		beq $eb2a			beq 	_GNEExit 						; if not, return with carry set.
.eb17	5a		phy				phy
.eb18	a0 04		ldy #$04			ldy 	#4 								; write to event.key.raw
.eb1a	91 f0		sta ($f0),y			sta 	(eventBuffer),y
.eb1c	c8		iny				iny 									; write to event.key.ascii
.eb1d	91 f0		sta ($f0),y			sta 	(eventBuffer),y
.eb1f	a9 00		lda #$00			lda 	#0
.eb21	c8		iny				iny
.eb22	91 f0		sta ($f0),y			sta 	(eventBuffer),y 				; write zero to flags.
.eb24	7a		ply				ply
.eb25	a9 08		lda #$08			lda 	#8 								; event type - this is key pressed.
.eb27	92 f0		sta ($f0)			sta 	(eventBuffer)
.eb29	18		clc				clc 									; event occurred.
.eb2a					_GNEExit:
.eb2a	60		rts				rts
.ff00	4c 0f eb	jmp $eb0f		jmp 	GetNextEvent
.ffcf					Disable1:
.ffcf	4c ec e8	jmp $e8ec		jmp 	NewReadKeyboard
.ffd2	4c 6c e7	jmp $e76c		jmp 	PrintCharacter
.ffe1	4c 32 e8	jmp $e832		jmp 	ControlCCheck
.ffe4	4c fd e8	jmp $e8fd		jmp 	GetKeyIfPressed
.ffe7	4c b5 ea	jmp $eab5		jmp 	ReadKeyboardStatusTable
.ffea	4c c7 e6	jmp $e6c7		jmp	 	ClearScreen
>fff8	40 80					.word 	$8040
>fffa	e8 e7					.word 	NMIHandler                       	; nmi ($FFFA)
>fffc	1a e9					.word 	SystemReset                         ; reset ($FFFC)
>fffe	e4 e0					.word 	IRQHandler                          ; irq ($FFFE)

;******  End of listing
